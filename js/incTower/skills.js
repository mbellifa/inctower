define(['incTower/core', 'lib/knockout', 'lib/bignumber', 'lib/moment', 'lib/lodash', 'lib/ko.observableDictionary', 'lib/jstree', 'incTower/util',  'incTower/tooltips'], function (incTower, ko, BigNumber, moment, _) {
    'use strict';
    var humanizeNumber = incTower.humanizeNumber;
    function SkillCollection() { //Describes a collection of skills at a certain rank.
        this.collection = {};
        this.pairs = [];
        this.add = function (pair) {
            var skill = pair[0];
            var level = pair[1];
            if (this.collection[skill]) {
                if (level > this.collection[skill]) {
                    this.collection[skill] = level;
                    var index = _.findIndex(this.pairs, function (findPair) { return findPair[0] === skill; });
                    this.pairs[index] = [skill, level];
                }
                return;
            }
            this.collection[skill] = level;
            this.pairs.push(pair);
        };
        this.merge = function (otherCollection) {
            var _this = this;
            _.forEach(otherCollection.pairs, function (otherItem) {
                _this.add(otherItem);
            });
        };
        this.difference = function (otherCollection) {
            //Returns a new collection which is all skills in this collection that are not included in the other collection
            var ret = new SkillCollection();
            _.forEach(this.pairs, function(pair) {
               if (!otherCollection.contains(pair[0], pair[1])) {
                   ret.add(pair);
               }
            });
            return ret;
        };
        this.empty = function () {
            return this.pairs.length === 0;
        };
        this.contains = function (skill, level) { // Returns true if we have the skill at a given level, level defaults to 1
            level = level || 1;
            if (!this.collection[skill]) { return false; }
            return this.collection[skill] >= level;
        };

    };
    incTower.skillAttributes = {
        construction: {
            fullName: 'Construction',
            baseCost: 14.775,
            growth: 1.15,
            describeRank: function (rank) {
                return 'Reduces the cost of towers and their upgrades by ' + rank + '%.';
            },
            maxLevel: 10,
            grants: {
                10: ['modularConstruction', 'initialEngineering']
            }
        },
        modularConstruction: {
            fullName: 'Modular Construction',
            baseCost: 135,
            growth: 1.15,
            describeRank: function (rank) {
                return 'Reduces the cost of upgrading all towers by ' + (rank * 5) + '%.';
            },
            maxLevel: 5,
            grants: {
                5: ['adaptiveUpgrades']
            }
        },
        adaptiveUpgrades: {
            fullName: 'Adaptive Upgrades',
            baseCost: 177.307,
            growth: 1.15,
            describeRank: function (rank) {
                return "Each hit from a tower now reduces its upgrade cost by " + (rank * 0.1) + "% of the monster's gold value. Towers will automatically upgrade when their upgrade cost reaches zero.";
            },
            maxLevel: 10
        },
        initialEngineering: {
            fullName: 'Initial Engineering',
            baseCost: 135,
            growth: 1.15,
            describeRank: function (rank) {
                return 'Increases the starting damage, attack speed, and range for all towers by ' + (rank * 5) + '%.';
            },

            maxLevel: 5,
            grants: {
                5: ['towerTemplates', 'scrapping']
            }
        },
        towerTemplates: {
            fullName: 'Tower Templates',
            baseCost: 3600,
            growth: 2,
            describeRank: function (rank) {
                return 'Allows you to create blueprints from existing towers, increasing the base damage of that type of tower.';
            },
            maxLevel: 1,
            grants: {
                1: ['refinedBlueprints']
            },
            onMax: function () {
                incTower.addToObsArray(incTower.availableActions, 'template');
            }
        },
        scrapping: {
            fullName: 'Scrapping',
            baseCost: 533.938,
            growth: 1.15,
            describeRank: function (rank) {
                return 'Refunds an additional ' + (rank * 5) + '% of gold spent after the sale of a tower.';
            },
            maxLevel: 5
        },
        refinedBlueprints: {
            fullName: 'Refined Blueprints',
            baseCost: 1054.238,
            growth: 1.15,
            describeRank: function (rank) {
                return 'Increases the number of blueprint points generated by creating a template by ' + (rank * 5) + '%.';
            },
        },
        investment: {
            fullName: 'Investment',
            baseCost: 8.785,
            growth: 1.15,
            describeRank: function (rank) {
                return 'Passively gain ' + (rank) + ' gold per second.';
            },
            grants: {
                10: ['marketConnections']
            }

        },
        marketConnections: {
            fullName: 'Market Connections',
            baseCost: 35.141,
            growth: 1.15,
            describeRank: function (rank) {
                return 'Increases the gold reward on each kill by ' + (rank) + '%.';
            }


        },
        kineticTowers: {
            fullName: 'Kinetic Towers',
            baseCost: 14.775,
            growth: 1.15,
            maxLevel: 10,
            describeRank: function (rank) {
                return 'Increases the damage that kinetic towers deal by ' + (5 * rank) + '%.';
            },
            grants: {
                10: ['shrapnelAmmo', 'kineticAmmo']
            }
        },
        shrapnelAmmo: {
            fullName: 'Shrapnel Ammo',
            baseCost: 900,
            growth: 1.1,
            maxLevel: 1,
            describeRank: function (rank) {
                return 'Allows your kinetic towers to be equipped with shrapnel rounds which will do less damage initially but will always cause bleeding.';
            },
            grants: {
                1: ['anticoagulants']
            },
            onMax: function () {
                incTower.addToObsArray(incTower.towerAttributes.kinetic.ammoTypes, 'shrapnel');
            }
        },
        anticoagulants: {
            fullName: 'Anti-Coagulants',
            baseCost: 175.707,
            growth: 1.15,
            describeRank: function (rank) {
                if (rank < 40) {
                    return 'Bleeding is reduced by ' + humanizeNumber(50 - 1.25 * rank) + '% each tick instead of the base 50%.';
                }
                if (rank === 40) {
                    return 'Bleeding is no longer reduced over time.';
                }
                if (rank > 40) {
                    return 'Instead of bleed damage being reduced it is increased by ' + humanizeNumber(rank * 1.25) + '%.';
                }
            }
        },
        kineticAmmo: {
            fullName: 'Kinetic Ammo',
            baseCost: 35.142,
            growth: 1.15,
            describeRank: function (rank) {
                return 'Optimizes the damage caused by kinetic towers, increasing damage by ' + (rank * 5) + '%.';
            }
        },
        magicalAffinity: {
            fullName: 'Magical Affinity',
            baseCost: 300,
            growth: 1.1,
            maxLevel: 1,
            describeRank: function () {
                return "Grants magical affinity granting mana to casting spells, unlocks the spell Arcane Sacrifice, and unlocks elemental towers.";
            },
            onMax: function () {
                if (incTower.rawMaxMana().eq(0)) {
                    incTower.rawMaxMana(new BigNumber(1000));
                    incTower.mana(incTower.maxMana());
                }
                incTower.addToObsArray(incTower.availableTowers, 'elemental');
                incTower.addToObsArray(incTower.availableSpells, 'manaBurst');
                incTower.addToObsArray(incTower.availableSpells, 'arcaneSacrifice');


            },
            grants: {
                1: ['fireAffinity', 'waterAffinity', 'earthAffinity', 'airAffinity', 'wizardry']
            }
        },
        wizardry: {
            fullName: 'Wizardry',
            baseCost: 133.485,
            growth: 1.15,
            maxLevel: 5,
            describeRank: function (rank) {
                return "Increases arcane damage by " + (rank * 10) + '%.';
            },
            grants: {
                1: ['manaRegeneration', 'arcaneKnowledge']
            }
        },
        manaRegeneration: {
            fullName: 'Mana Regeneration',
            baseCost: 175.707,
            growth: 1.15,
            describeRank: function (rank) {
                return "Increases mana regeneration by " + rank + ' per second.';
            },
            grants: {
                20: ['manaRegenerationAdvanced']
            }
        },
        manaRegenerationAdvanced: {
            fullName: 'Mana Regeneration (Advanced)',
            baseCost: 1054.238,
            growth: 1.15,
            describeRank: function (rank) {
                return "Increases mana regeneration by " + (rank * 5) + '%.';
            }
        },
        arcaneKnowledge: {
            fullName: 'Arcane Knowledge',
            baseCost: 175.707,
            growth: 1.15,
            describeRank: function (rank) {
                return "Increases max mana by " + (rank * 5) + '%.';
            }
        },
        fireAffinity: {
            fullName: 'Fire Affinity',
            baseCost: 900,
            growth: 1.1,
            maxLevel: 1,
            describeRank: function (rank) {
                return "Attunes yourself with fire which allows you to build fire towers which burn enemies over time, causing them to take increased damage from all sources.";
            },
            onMax: function () {
                incTower.addToObsArray(incTower.towerAttributes.elemental.ammoTypes, 'fireOrb');
                incTower.addToObsArray(incTower.towerAttributes.elemental.ammoTypes, 'fireCatalyst');
                incTower.addToObsArray(incTower.availableSpells, 'smolder');
            },
            grants: {
                1: ['fireRuneApplication', 'fireMastery']
            }
        },
        fireMastery: {
            fullName: 'Fire Mastery',
            baseCost: 175.707,
            growth: 1.15,
            describeRank: function (rank) {
                return "Increases all fire damage dealt by " + (rank * 10) + '%.';
            },
        },

        fireRuneApplication: {
            fullName: 'Fire Rune Application',
            baseCost: 100,
            growth: 1.266,
            maxLevel: 10,
            describeRank: function (rank) {
                return "Increases the chance that a fire tower successfully applies a rune by " + (rank * 5) + '%.';
            },
            grants: {
                10: ['fireAdvancedRuneApplication']
            }
        },
        fireAdvancedRuneApplication: {
            fullName: 'Fire Rune Application (Advanced)',
            baseCost: 886.538,
            growth: 1.15,
            maxLevel: 10,
            describeRank: function (rank) {
                return "When a fire tower successfully applies a rune, there is a " + (rank * 5) + '% chance that it will apply two instead.';
            }
        },
        waterAffinity: {
            fullName: 'Water Affinity',
            baseCost: 900,
            growth: 1.1,
            maxLevel: 1,
            describeRank: function (rank) {
                return "Attunes yourself with water which allows you to build water towers which slow and freeze enemies.";
            },

            onMax: function () {
                incTower.addToObsArray(incTower.towerAttributes.elemental.ammoTypes, 'waterOrb');
                incTower.addToObsArray(incTower.towerAttributes.elemental.ammoTypes, 'waterCatalyst');
                incTower.addToObsArray(incTower.availableSpells, 'frostShatter');
            },
            grants: {
                1: ['waterRuneApplication', 'waterMastery']
            }
        },
        waterMastery: {
            fullName: 'Water Mastery',
            baseCost: 175.707,
            growth: 1.15,
            describeRank: function (rank) {
                return "Increases all water damage dealt by " + (rank * 10) + '%.';
            },
        },
        waterRuneApplication: {
            fullName: 'Water Rune Application',
            baseCost: 100,
            growth: 1.266,
            maxLevel: 10,
            describeRank: function (rank) {
                return "Increases the chance that a water tower successfully applies a rune by " + (rank * 5) + '%.';
            },
            grants: {
                10: ['waterAdvancedRuneApplication']
            }
        },
        waterAdvancedRuneApplication: {
            fullName: 'Water Rune Application (Advanced)',
            baseCost: 886.538,
            growth: 1.15,
            maxLevel: 10,
            describeRank: function (rank) {
                return "When a water tower successfully applies a rune, there is a " + (rank * 5) + '% chance that it will apply two instead.';
            }
        },

        earthAffinity: {
            fullName: 'Earth Affinity',
            baseCost: 900,
            growth: 1.1,
            maxLevel: 1,
            describeRank: function (rank) {
                return "Attunes yourself with earth which allows you to build earth towers which drop giant boulders from the sky, causing area of effect damage.";
            },

            onMax: function () {
                incTower.addToObsArray(incTower.towerAttributes.elemental.ammoTypes, 'earthOrb');
                incTower.addToObsArray(incTower.towerAttributes.elemental.ammoTypes, 'earthCatalyst');
                incTower.addToObsArray(incTower.availableSpells, 'seismicRupture');

            },
            grants: {
                1: ['earthRuneApplication', 'earthMastery']
            }

        },
        earthMastery: {
            fullName: 'Earth Mastery',
            baseCost: 175.707,
            growth: 1.15,
            describeRank: function (rank) {
                return "Increases all earth damage dealt by " + (rank * 10) + '%.';
            },
        },

        earthRuneApplication: {
            fullName: 'Earth Rune Application',
            baseCost: 100,
            growth: 1.266,
            maxLevel: 10,
            describeRank: function (rank) {
                return "Increases the chance that an earth tower successfully applies a rune by " + (rank * 5) + '%.';
            },
            grants: {
                10: ['earthAdvancedRuneApplication']
            }
        },
        earthAdvancedRuneApplication: {
            fullName: 'Earth Rune Application (Advanced)',
            baseCost: 886.538,
            growth: 1.15,
            maxLevel: 10,
            describeRank: function (rank) {
                return "When an earth tower successfully applies a rune, there is a " + (rank * 5) + '% chance that it will apply two instead.';
            },
        },

        airAffinity: {
            fullName: 'Air Affinity',
            baseCost: 900,
            growth: 1.1,
            maxLevel: 1,
            describeRank: function (rank) {
                return "Attunes yourself with air which allows you to build air towers which will occasionally trap enemies in a whirlwind, knocking them back.";
            },

            onMax: function () {
                incTower.addToObsArray(incTower.towerAttributes.elemental.ammoTypes, 'airOrb');
                incTower.addToObsArray(incTower.towerAttributes.elemental.ammoTypes, 'airCatalyst');
                incTower.addToObsArray(incTower.availableSpells, 'eyeOfTheStorm');
            },
            grants: {
                1: ['airRuneApplication', 'airMastery']
            }
        },
        airMastery: {
            fullName: 'Air Mastery',
            baseCost: 175.707,
            growth: 1.15,
            describeRank: function (rank) {
                return "Increases all air damage dealt by " + (rank * 10) + '%.';
            },
        },
        airRuneApplication: {
            fullName: 'Air Rune Application',
            baseCost: 100,
            growth: 1.266,
            maxLevel: 10,
            describeRank: function (rank) {
                return "Increases the chance that an air tower successfully applies a rune by " + (rank * 5) + '%.';
            },

            grants: {
                10: ['airAdvancedRuneApplication']
            }
        },
        airAdvancedRuneApplication: {
            fullName: 'Air Rune Application (Advanced)',
            baseCost: 886.538,
            growth: 1.15,
            maxLevel: 10,
            describeRank: function (rank) {
                return "When an air tower successfully applies a rune, there is a " + (rank * 5) + '% chance that it will apply two instead.';
            },
        },
        sensors: {
            fullName: 'Sensors',
            baseCost: 44.494,
            growth: 1.15,
            describeRank: function (rank) {
                return 'Increases tower range by ' + (rank * 5) + '%.';
            },
            maxLevel: 5,
            grants: {
                5: ['sensorArrays', 'sniperAmmo']
            }
        },
        sniperAmmo: {
            fullName: 'Sniper Ammo',
            baseCost: 900,
            growth: 1.2,
            describeRank: function (rank) {
                return 'Allows the construction of sensor arrays which periodically increase the range of towers adjacent to them.';
            },
            maxLevel: 1,
            onMax: function () {
                incTower.addToObsArray(incTower.towerAttributes.kinetic.ammoTypes, 'sniper');
            }

        },
        sensorArrays: {
            fullName: 'Sensor Arrays',
            baseCost: 900,
            growth: 1.2,
            describeRank: function (rank) {
                return 'Allows the construction of sensor arrays which periodically increase the range of towers adjacent to them.';
            },
            maxLevel: 1,
            onMax: function () {
                incTower.addToObsArray(incTower.towerAttributes.support.ammoTypes, 'sensor');
            },
            additionalPrereqs: [['powerDistribution', 1]]
        },



        powerDistribution: {
            fullName: 'Power Distribution',
            baseCost: 300,
            growth: 1.1,
            maxLevel: 1,
            describeRank: function () {
                return "Allows the construction of support towers which grant special effects and damage boosts to towers around them.";
            },
            onMax: function () {
                incTower.addToObsArray(incTower.availableTowers, 'support');
            },
            grants: {
                1: ['batteryLongevity']
            }

        },
        batteryLongevity: {
            fullName: 'Battery Longevity',
            baseCost: 233.485,
            growth: 1.15,
            maxLevel: 5,
            describeRank: function (rank) {
                return "Increases the duration of support tower buffs by " + (rank * 10) + '%.';
            },
        }

    };
    //Go through and reverse any grants to list parents
    _.forOwn(incTower.skillAttributes, function (attribs, name) {
        if (attribs.grants) {
            _.forOwn(attribs.grants, function (grantSkills, level) {
                level = parseInt(level);
                _.forEach(grantSkills, function (grantSkill) {
                    incTower.skillAttributes[grantSkill].parent = [name, level];
                });
            });
        }
    });


    incTower.skills = ko.observableDictionary({});
    incTower.skillQueue = ko.observableArray([]);
    incTower.clearQueue = function () {
        incTower.skillQueue.removeAll();
    };
    incTower.UIselectedSkill = ko.observable(false);
    incTower.activeSkill = ko.pureComputed(function () {
        if (incTower.skillQueue().length === 0) {
            return false;
        }
        return incTower.skillQueue()[0][0];
    });
    incTower.skillQueue.subscribe(function () {
        //Whenever the active skill changes make sure our tooltip updates
        incTower.checkTooltips();
    });
    incTower.getSkillTreeLabel = function (skillName) {
        var maxLevel = incTower.skillAttributes[skillName].maxLevel;
        if (maxLevel === undefined) { maxLevel = '&infin;'; }
        var currentLevel = '--';
        var stars = '';
        if (incTower.haveSkill(skillName)) {
            currentLevel = incTower.getSkillLevel(skillName);
            stars = _.repeat('&#9733;', Math.floor(currentLevel / 20));
        }
        return incTower.skillAttributes[skillName].fullName + stars + ' (' + currentLevel + ' / ' + maxLevel + ')';
    };
    incTower.skillTreeUpdateLabel = function (skillName) {
        $('#skills_tree').jstree('rename_node', '#' + skillName, incTower.getSkillTreeLabel(skillName));
    };
    incTower.skillTreeMode = ko.observable('tree');
    incTower.skillTreeMode.subscribe(function (newVal) {
       if (newVal === 'flat') {
           $('#skills_tree').jstree(true).settings.core.data = incTower.skillTreeDataFlat();
           $('#skills_tree').jstree(true).refresh();
       } else {
           $('#skills_tree').jstree(true).settings.core.data = incTower.skillTreeData();
           $('#skills_tree').jstree(true).refresh();
       }
    });
    incTower.checkQueue = function () {
        while (true) {
            if (incTower.skillQueue().length === 0) {
                break;
            }
            var firstItem = incTower.skillQueue()[0];
            if (incTower.getSkillLevel(firstItem[0]) !== firstItem[1] - 1) {
                incTower.skillQueue.shift();
            } else {
                break;
            }
        }

    };
    incTower.skillHasMax = function (skillName) {
        return incTower.skillAttributes[skillName].maxLevel !== undefined;
    };
    incTower.skillGetPrereqs = function (skillNameToFind) {
        if (incTower.skillAttributes[skillNameToFind].prereqs) {
            return incTower.skillAttributes[skillNameToFind].prereqs;
        }
        if (!incTower.skillAttributes[skillNameToFind].parent) {
            incTower.skillAttributes[skillNameToFind].prereqs = new SkillCollection();
            return incTower.skillAttributes[skillNameToFind].prereqs;
        }
        var ret = new SkillCollection();
        ret.add(incTower.skillAttributes[skillNameToFind].parent);
        ret.merge(incTower.skillGetPrereqs(incTower.skillAttributes[skillNameToFind].parent[0]));
        if (incTower.skillAttributes[skillNameToFind].additionalPrereqs) {
            _.forEach(incTower.skillAttributes[skillNameToFind].additionalPrereqs, function (preReq) {
                ret.add(preReq);
                ret.merge(incTower.skillGetPrereqs(preReq[0]));
            });
        }
        incTower.skillAttributes[skillNameToFind].prereqs = ret;
        return ret;
    };
    incTower.skillIsMaxed = function (skillName) {
        if (!skillName) { return false; }
        var maxLevel = incTower.skillAttributes[skillName].maxLevel;
        return maxLevel && incTower.getSkillLevel(skillName) >= maxLevel;
    };

    incTower.skillRankInQueue = function (skill) {
        var minRank = 0;
        _.map(incTower.skillQueue(), function (item) {
            if (item[0] === skill) {
                minRank = item[1];
            }
        });
        return minRank;
    };
    incTower.skillMaxedInQueue = function (skill) {
        if (!skill) { return false; }
        var minRank = incTower.skillRankInQueue(skill) + 1;
        if (incTower.skillAttributes[skill].maxLevel !== undefined && minRank > incTower.skillAttributes[skill].maxLevel) {
            return true;
        }
        return false;
    };
    incTower.directlyQueueable = function (skill) {
        if (!(skill in incTower.skillAttributes)) {
            return false;
        }
        //Returns the rank trainable in the skill if it is directly trainable, meaning all prereqs are met in the queue already, otherwise false
        var minRank = Math.max(incTower.getSkillLevel(skill), incTower.skillRankInQueue(skill)) + 1;
        if (incTower.skillAttributes[skill].maxLevel !== undefined && minRank > incTower.skillAttributes[skill].maxLevel) {
            return false;
        }
        var prereqs = incTower.skillGetPrereqs(skill);
        var diff = prereqs.difference(incTower.getCurrentSkills(true));
        if (!diff.empty()) { return false; }
        return minRank;
    };
    incTower.getCurrentSkills = function (includingQueue) { // Returns a skill collection of currently skills, possibly including current queue
        var ret = new SkillCollection();
        _.forEach(incTower.skills.keys(), function (skill) {
           ret.add([skill, incTower.getSkillLevel(skill)]);
        });
        if (includingQueue) {
            _.forEach(incTower.skillQueue(), function (item) {
                ret.add(item);
            });
        }
        return ret;
    };
    incTower.checkPotentialQueue = function (potentialList) {
        var skillTally = incTower.getCurrentSkills();
        var valid = true;
        _.forEach(potentialList, function (item) {
            if (!valid) { return false; }
            var skill = item[0];
            var rank = item[1];
            if (rank > 1 && !skillTally.contains(skill, rank - 1)) {
                valid = false;
            }
            var prereqs = incTower.skillGetPrereqs(skill);
            var diff = prereqs.difference(skillTally);
            if (!diff.empty()) { valid = false; }
            if (valid) { skillTally.add(item); }
        });
        return valid;
    };
    incTower.directlyRemovable = function (skill, rank) {
        var potentialList = _.clone(incTower.skillQueue());
        _.remove(potentialList, function (item) {
            return item[0] === skill && item[1] === rank;
        });
        return incTower.checkPotentialQueue(potentialList);
    };
    incTower.enqueueSkill = function (skill) {
        var minRank = incTower.directlyQueueable(skill);
        if (minRank === false) { return false; }
        incTower.skillQueue.push([skill, minRank]);
    };
    incTower.skillCanTrain = function (skillName) {
        if (incTower.skillIsMaxed(skillName)) { return false; }
        if (incTower.activeSkill() === skillName) { return false; } //Can't train the skill you're already training
        return true;
    };
    incTower.skillTextProgress = function (skillName) {
        if (incTower.skillAttributes[skillName] === undefined) {
            return "";
        }
        var skill = incTower.skills.get(skillName)();
        if (skill === null) {
            return "";
        }
        //if (skill.get('skillPoints')() === null) { return ""; }
        if (incTower.skillIsMaxed(skillName)) {
            return "Maxed";
        }
        return humanizeNumber(skill.get('skillPoints')()) + " / " + humanizeNumber(skill.get('skillPointsCap')());
    };

    incTower.startingSkills = ['kineticTowers', 'construction', 'magicalAffinity', 'sensors', 'investment', 'powerDistribution'];
    incTower.gainSkill = function (name, opt) {
        if (typeof opt === 'undefined') {
            opt = {};
        }
        if (!(name in incTower.skillAttributes)) {
            console.log(name + " is not in our skills list.");
        }
        /*if (incTower.getSkillLevel(name) !== -1) { return; } //We already know the skill*/
        //Either gains a new skill at level 1 or loads in a previously saved skill
        var skillLevel = opt.skillLevel || 0;
        var skillPoints = new BigNumber(opt.skillPoints || 0);
        var skillPointsCap = incTower.costCalc(incTower.skillAttributes[name].baseCost, skillLevel, incTower.skillAttributes[name].growth);
        incTower.skills.push(name, ko.observableDictionary({
            skillLevel: skillLevel,
            skillPoints: skillPoints,
            skillPointsCap: skillPointsCap
        }));
        incTower.checkSkill(name);
        //incTower.skillTreeUpdateLabel(name);
    };
    incTower.describeSkill = function (name) {
        if (!incTower.skillAttributes[name]) {
            return '';
        }
        var currentLevel = incTower.getSkillLevel(name);
        var desc = '';
        var maxed = incTower.skillIsMaxed(name);
        if (currentLevel > 0) {
            desc += "<p>" + incTower.skillAttributes[name].describeRank(incTower.levelToEffective(currentLevel)) + '</p>';
        }
        if (!maxed) {
            desc += '<p>Next Rank: ' + incTower.skillAttributes[name].describeRank(incTower.levelToEffective(currentLevel + 1)) + '</p>';
        }
        var grants = incTower.skillAttributes[name].grants;
        if (grants !== undefined) {
            _.mapValues(grants, function (skills, level) {
                var fullSkillNames = _.map(skills, function (skill) {
                    return incTower.skillAttributes[skill].fullName;
                });
                fullSkillNames = incTower.prettyCommaList(fullSkillNames);
                desc += '<p>Grants ' + fullSkillNames + ' at level ' + level + '.</p>';

            });

        }
        return desc;
    };
    incTower.getSkillLevel = function (name) {
        if (incTower.skills.get(name)() === null) {
            return 0;
        }
        return incTower.skills.get(name)().get('skillLevel')();
    };
    incTower.getEffectiveSkillLevel = function (name) {
        return incTower.levelToEffective(incTower.getSkillLevel(name));
    };
    incTower.levelToEffective = function (skillLevel) {
        return skillLevel * Math.pow(2, Math.floor(skillLevel / 20));
    };
    incTower.possibleGrants = function (skill, atLevel) {
        if (atLevel === undefined) {
            return _.flatten(_.values(incTower.skillAttributes[skill].grants));
        }
        var grants = [];
        _.mapValues(incTower.skillAttributes[skill].grants, function (skills, level) {
            if (atLevel >= level) {
                grants = grants.concat(skills);
            }
        });
        return grants;
    };
    incTower.checkSkills = function () {
        _.map(incTower.skills.keys(), incTower.checkSkill);
    };
    incTower.checkSkill = function (skill) {
        //console.log("CHECK : " + skill);
        var toAdd = [];
        if (incTower.skillAttributes[skill].maxLevel !== undefined && incTower.getSkillLevel(skill) > incTower.skillAttributes[skill].maxLevel) {
            incTower.skills.get(skill)().get('skillLevel')(incTower.skillAttributes[skill].maxLevel);
        }
        if (incTower.skillAttributes[skill].onMax !== undefined && incTower.skillIsMaxed(skill)) {
            incTower.skillAttributes[skill].onMax();
        }
        if (incTower.skillAttributes[skill].grants !== undefined) {
            var curLevel = incTower.getSkillLevel(skill);
            _.keys(incTower.skillAttributes[skill].grants).map(function (level) {
                if (curLevel >= level) {
                    toAdd = toAdd.concat(incTower.skillAttributes[skill].grants[level]);
                }
            });
        }
        //console.log(toAdd);
        _.map(toAdd, function (skill) {
            if (!incTower.haveSkill(skill)) {
                incTower.gainSkill(skill);
            }
        });
        incTower.skillTreeUpdateLabel(skill);
    };
    incTower.haveSkill = function (name) {
        return incTower.skills.get(name)() !== null;
    };
    incTower.getActiveSkillName = function () {
        var active = incTower.activeSkill();
        if (active in incTower.skillAttributes) {
            return incTower.skillAttributes[active].fullName;
        }
        return '';
    };
    incTower.skillPoints = ko.observable(new BigNumber(0));
    incTower.skillRate = function () {
        return 1 + 0.01 * incTower.prestigePointsEffective();
    };
    incTower.timeUntilSkillUp = function (pointDiff) {
        return moment().add(pointDiff / incTower.skillRate(), 'seconds').fromNow();
    };
    incTower.getSkillPointCap = function(skillName, rank) {
        var skillEntry = incTower.skillAttributes[skillName];
        return incTower.costCalc(skillEntry.baseCost, rank, skillEntry.growth);
    };

    incTower.skillDescribeTimeAdded = function (skill) {
        var directlyQueueable = incTower.directlyQueueable(skill);
        if (directlyQueueable) {
            var pointsRequired = incTower.costCalc(incTower.skillAttributes[skill].baseCost, directlyQueueable, incTower.skillAttributes[skill].growth);
            if (incTower.skillPoints().gt(0)) {
                var skillPointsRemaining =  pointsRequired.minus(incTower.skillPoints());
                if (skillPointsRemaining.gt(0)) {
                    return incTower.humanizeNumber(incTower.skillPoints()) + " Skill Points and " + moment().add(skillPointsRemaining.dividedBy(incTower.skillRate()).toNumber(), 'seconds').fromNow(true);
                } else {
                    return incTower.humanizeNumber(pointsRequired) + " Skill Points";
                }

            }
            return moment().add(pointsRequired.dividedBy(incTower.skillRate()).toNumber(), 'seconds').fromNow(true);
        }
    };
    incTower.calcSkillRaw = function(base, growth, toLevel) {
        var tally = new BigNumber(0);
        for (var i = 0; i < toLevel;i++) {
            tally = tally.plus(incTower.costCalc(base,i,growth));
        }
        return tally;
    };

    incTower.calcSkill = function (skill,toLevel) {
        return incTower.calcSkillRaw(incTower.skillAttributes[skill].baseCost, incTower.skillAttributes[skill].growth, toLevel);
    };
    incTower.calcSkillGrowth = function (skill,toLevel,targetTime) {
        var toggle = 1;
        targetTime = new BigNumber(targetTime);
        while (1) {
            var baseGrowth = incTower.skillAttributes[skill].growth;
            var posGrowth = baseGrowth + toggle;
            var negGrowth = baseGrowth - toggle;
            var zeroval = incTower.calcSkill(skill,toLevel).minus(targetTime).abs();
            incTower.skillAttributes[skill].growth = posGrowth;
            var posval = incTower.calcSkill(skill,toLevel).minus(targetTime).abs();
            incTower.skillAttributes[skill].growth = negGrowth;
            var negval = incTower.calcSkill(skill,toLevel).minus(targetTime).abs();
            if (zeroval.lt(posval) && zeroval.lt(negval)) {
                console.log("Within " + zeroval.toJSON() + " at " + baseGrowth);
                if (zeroval.lt(1)) { break; }
                toggle /= 2;
            } else if (posval.lt(negval)) {
                console.log("Within " + posval.toJSON() + " at " + posGrowth);
                incTower.skillAttributes[skill].growth = posGrowth;
            } else {
                console.log("Within " + negval.toJSON() + " at " + negGrowth);
                incTower.skillAttributes[skill].growth = negGrowth;
            }
        }
    };
    incTower.calcSkillGrowthTier = function (skill, tier) {
        var maxedTierTimes = [
            300,
            900,
            3600,
            18000,
            108000,
            648000,
            4536000

        ];
        var baseToggle = 1;
        var targetTime = new BigNumber(maxedTierTimes[tier]);
        var baseGrowth = incTower.skillAttributes[skill].growth;
        var baseCost = incTower.skillAttributes[skill].baseCost;
        var targetLevel = 20;
        if (incTower.skillAttributes[skill].maxLevel) {
            targetLevel = incTower.skillAttributes[skill].maxLevel;
            targetTime = new BigNumber(maxedTierTimes[tier - 1]);
        }
        var zeroval;

        while (1) {


            zeroval = incTower.calcSkillRaw(baseCost, baseGrowth, targetLevel).minus(targetTime).abs();
            var posval = incTower.calcSkillRaw(baseCost + baseToggle, baseGrowth, targetLevel).minus(targetTime).abs();
            var negval = incTower.calcSkillRaw(baseCost - baseToggle, baseGrowth, targetLevel).minus(targetTime).abs();
            if (zeroval.lt(posval) && zeroval.lt(negval)) {
                console.log("Within " + zeroval.toJSON() + " at growth: " + baseGrowth + " base: " + baseCost);
                baseToggle /= 2;
                if (baseToggle < 0.001) {
                    break;
                }


            } else if (posval.lt(negval)) {
                baseCost += baseToggle;
            } else {
                baseCost -= baseToggle;
            }

        }
        baseCost = parseFloat(baseCost.toFixed(3));
        console.log("Within " + zeroval.toJSON() + " at growth: " + baseGrowth + " base: " + baseCost);

    };
    incTower.skillReport = function (skill, tier) {
        if (!skill) {
            _.forEach(incTower.startingSkills, function (skill) {
                incTower.skillReport(skill, 1);
            });
            return;
        }
        var maxedTierTimes = [
            300,
            900,
            3600,
            18000,
            108000,
            648000,
            4536000

        ];
        var maxLevel = incTower.skillAttributes[skill].maxLevel;
        if (!maxLevel) {
            var timeTo20 = incTower.calcSkill(skill, 20);
            var timeTo40 = incTower.calcSkill(skill, 40);
            if (timeTo20.div(maxedTierTimes[tier]).minus(1).abs().gt(0.05)) {
                console.log(_.repeat('-', tier) + ' ' + skill + ' ' + 'Achieves 20 in ' + incTower.humanizeNumber(timeTo20) + ' and 40 in ' + incTower.humanizeNumber(timeTo40));
                console.log('Should be ' + maxedTierTimes[tier]);
            }
        } else {
            if (incTower.calcSkill(skill, maxLevel).div(maxedTierTimes[tier - 1]).minus(1).abs().gt(0.05)) {
                console.log(_.repeat('-', tier) + ' ' + skill + ' ' + 'Achieves ' + maxLevel + ' in ' + incTower.humanizeNumber(incTower.calcSkill(skill, maxLevel)));
                console.log('Should be ' + maxedTierTimes[tier - 1]);
            }

        }
        if (incTower.skillAttributes[skill].grants !== undefined) {
            _.mapValues(incTower.skillAttributes[skill].grants, function (skills, level) {
                _.forEach(skills, function (newSkill) {
                    incTower.skillReport(newSkill, tier + 1);
                });
            });

        }

    };
    incTower.secondsUntilSkillUp = ko.computed(function () {
        if (this.skills.get(this.activeSkill())() === null) { return 0; }
        return this.skills.get(this.activeSkill())().get('skillPointsCap')().minus(this.skills.get(this.activeSkill())().get('skillPoints')());
    },incTower);
    incTower.secondsUntilQueueExhausted = ko.computed(function () {
        if (this.skillQueue().length === 0) { return 0; }
        var tally = new BigNumber(0);
        _.forEach(this.skillQueue(), function (item) {
            var skill = item[0];
            var rank = item[1];
            if (incTower.haveSkill(skill) && incTower.getSkillLevel(skill) === rank - 1) {
                tally = tally.plus(incTower.skills.get(skill)().get('skillPointsCap')().minus(incTower.skills.get(skill)().get('skillPoints')()));
            } else {
                tally = tally.plus(incTower.costCalc(incTower.skillAttributes[skill].baseCost,rank,incTower.skillAttributes[skill].growth));
            }
        }, this);
        return tally;
    },incTower);
    incTower.percentageUntilSkillUp = ko.computed(function () {
        if (this.skills.get(this.activeSkill())() === null) { return 0; }
        return this.skills.get(this.activeSkill())().get('skillPoints')().dividedBy(this.skills.get(this.activeSkill())().get('skillPointsCap')()).times(100);
    },incTower);
    incTower.skillTreeData = function () {
        var data = [];
        function addSkillToData (skill, parent) {
            if (parent === undefined) { parent = "#"; }
            var label = incTower.getSkillTreeLabel(skill);
            data.push({id: skill, parent: parent, text: label });
            if (incTower.skillAttributes[skill].grants !== undefined) {
                var origin = skill;
                _.map(incTower.possibleGrants(skill), function (skill) {
                    addSkillToData(skill, origin);
                });
            }
        }
        _.map(incTower.startingSkills,function (skill) { addSkillToData(skill); });
        return data;
    };
    incTower.skillTreeDataFlat = function () {
        var data = [];
        function addSkillToData (skill) {
            var currentLevel = '--';
            if (incTower.haveSkill(skill)) { currentLevel = incTower.getSkillLevel(skill); }
            var maxLevel = incTower.skillAttributes[skill].maxLevel;
            if (incTower.skillAttributes[skill].grants !== undefined) {
                _.map(incTower.possibleGrants(skill), function (skill) {
                    addSkillToData(skill);
                });
            }
            if (maxLevel !== undefined && currentLevel !== '--' && currentLevel === maxLevel) {
                return;
            }

            var label = incTower.getSkillTreeLabel(skill);
            data.push({id: skill, parent: '#', text: label });

        }
        _.map(incTower.startingSkills,function (skill) { addSkillToData(skill); });
        data = _.sortBy(data, ['text']);
        return data;
    };

    _.forEach(incTower.startingSkills, function (skill) {
        if (!incTower.haveSkill(skill)) {
            incTower.gainSkill(skill);
        }
    });

});
